<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<title>Mesmerizing Orbital Dance — Live Geometry</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  html,body { height:100%; margin:0; background:#000; overflow:hidden; }
  canvas { display:block; width:100%; height:100%; }
  #ui {
    position:fixed; left:12px; top:12px; z-index:20;
    color:#fff; font-family:Inter,system-ui,monospace; font-size:13px;
    background:rgba(0,0,0,0.25); padding:10px; border-radius:8px;
    backdrop-filter: blur(4px);
  }
  #ui input[type=range]{ width:140px; }
  #hint{ opacity:0.9; margin-top:6px; font-size:12px; color:#ddd; }
  a { color:#9cf; }
</style>
</head>
<body>
<div id="ui">
  <div>Seed: <input id="seed" type="number" value="424242" style="width:110px" /></div>
  <div style="margin-top:6px">Orbit layers: <input id="layers" type="range" min="3" max="12" value="7" /></div>
  <div>Glow intensity: <input id="glow" type="range" min="0.5" max="3" step="0.1" value="1.4" /></div>
  <div style="margin-top:6px" id="hint">Space = pause • S = save PNG • drag seed to change • resize window to reset</div>
</div>

<canvas id="c"></canvas>

<script>
(() => {
  // --- utilities ---
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: true });
  let W = canvas.width = innerWidth;
  let H = canvas.height = innerHeight;
  function resize(){ W = canvas.width = innerWidth; H = canvas.height = innerHeight; initSystem(); }
  addEventListener('resize', resize, {passive:true});

  // PRNG (mulberry32) for deterministic seeds
  function mulberry32(a) {
    return function() {
      a |= 0;
      a = a + 0x6D2B79F5 | 0;
      let t = Math.imul(a ^ a >>> 15, 1 | a);
      t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
      return ((t ^ t >>> 14) >>> 0) / 4294967296;
    };
  }

  // lerp helper
  const lerp = (a,b,t) => a + (b-a)*t;

  // UI elements
  const seedInput = document.getElementById('seed');
  const layersInput = document.getElementById('layers');
  const glowInput = document.getElementById('glow');

  // state
  let paused = false;
  let time = 0;
  let systems = []; // orbit layers
  let rng = mulberry32(Number(seedInput.value) || 1);
  let baseHue = (rng()*360)|0;

  // keyboard controls
  addEventListener('keydown', (e) => {
    if (e.code === 'Space') { paused = !paused; e.preventDefault(); }
    if (e.key.toLowerCase() === 's') savePNG();
  });

  // mouse drag change seed (nice interactive tweak)
  let draggingSeed = false;
  seedInput.addEventListener('input', () => { rng = mulberry32(Number(seedInput.value) || 1); initSystem(); });

  // when user moves orbit layers slider -> reinit
  layersInput.addEventListener('input', initSystem);
  glowInput.addEventListener('input', () => {}); // reactive in draw

  // save canvas
  function savePNG(){
    const a = document.createElement('a');
    a.href = canvas.toDataURL('image/png');
    a.download = `orbital-dance-seed-${seedInput.value}.png`;
    a.click();
  }

  // build the orbital layers with random-ish params
  function initSystem(){
    systems = [];
    const layers = Number(layersInput.value) || 7;
    rng = mulberry32(Number(seedInput.value) || 1);
    baseHue = Math.floor(rng()*360);
    // central star
    const maxR = Math.min(W,H) * 0.45;
    for (let i = 0; i < layers; i++){
      // each layer is an ellipse/orbit with its own speed, tilt, color
      const t = i / Math.max(1,layers-1);
      const radius = lerp(maxR*0.08, maxR*(0.98 - 0.1*t), 1 - Math.pow(t,1.1));
      const ecc = lerp(0.02, 0.6, rng());            // eccentricity (how elliptical)
      const tilt = lerp(0, Math.PI*0.6, rng());     // tilt angle
      const spin = lerp(0.0006, 0.004, 1 - t) * (rng() > 0.5 ? 1 : -1); // angular speed
      const phase = rng()*Math.PI*2;
      const points = Math.max(1, Math.floor(lerp(2, 12, 1 - t))); // bodies on this orbit
      const hueShift = Math.floor((baseHue + lerp(-40, 40, rng())) % 360);
      systems.push({ radius, ecc, tilt, spin, phase, points, hueShift, t });
    }
  }

  // helper: draw glowing circle with additive blending; radius, intensity
  function drawGlow(x, y, r, color, intensity=1.0){
    const g = ctx.createRadialGradient(x, y, 0, x, y, r);
    g.addColorStop(0, `hsla(${color.h}, ${color.s}%, ${color.l}%, ${0.35*intensity})`);
    g.addColorStop(0.15, `hsla(${color.h}, ${color.s}%, ${Math.min(90,color.l+20)}%, ${0.12*intensity})`);
    g.addColorStop(0.4, `hsla(${color.h}, ${color.s}%, ${Math.min(60,color.l)}%, ${0.028*intensity})`);
    g.addColorStop(1, `hsla(${color.h}, ${color.s}%, ${Math.max(6,color.l-40)}%, 0)`);
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI*2);
    ctx.fill();
  }

  // render single frame
  function render(dt){
    // subtle fade: paint a translucent black rectangle to create trails
    // tweak alpha to control trail length
    ctx.globalCompositeOperation = 'source-over';
    ctx.fillStyle = 'rgba(0,0,0,0.12)';
    ctx.fillRect(0,0,W,H);

    // center
    const cx = W/2, cy = H/2;

    // background stars (static-ish)
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    for (let i=0;i<60;i++){
      // draw small faint stars every frame but using deterministic RNG per-star index for consistency
      const a = (i*53 + Number(seedInput.value)) % 1000;
      const rr = ((a*9301 + 49297) % 233280) / 233280;
      const x = (rr*0.97 + 0.015) * W;
      const y = (((a*9301 + 3) % 233280)/233280*0.97 + 0.015) * H;
      const s = 0.6 + ((a*9301+7)%10)/10;
      ctx.fillStyle = `rgba(255,255,255,${0.02 + s*0.01})`;
      ctx.beginPath(); ctx.arc(x,y,s,0,Math.PI*2); ctx.fill();
    }
    ctx.restore();

    // draw central glowing star
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    const starHue = (baseHue + Math.sin(time*0.001)*8) % 360;
    drawGlow(cx, cy, Math.min(W,H)*0.08, {h:starHue, s:85, l:55}, 1.2 * Number(glowInput.value));
    // bright core
    ctx.beginPath();
    ctx.fillStyle = `hsl(${starHue} 90% 60%)`;
    ctx.arc(cx,cy, Math.min(W,H)*0.015, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    // Render each orbit layer and its bodies
    ctx.save();
    // rotate entire coordinate system slowly for cinematic effect
    const globalRotate = Math.sin(time*0.0004 + rng()*7) * 0.4 + time*0.00005;
    ctx.translate(cx, cy);
    ctx.rotate(globalRotate);
    for (let layer of systems){
      // slightly change params through time for a living system
      const wob = Math.sin(time*0.0003* (1+layer.t*2) + layer.phase*2) * (layer.radius*0.015) * (0.6 + 0.8*rng());
      const rX = layer.radius + wob;
      const rY = layer.radius * (1 - layer.ecc) + wob*0.6;

      // draw the ellipse path (thin faint line)
      ctx.save();
      ctx.rotate(layer.tilt);
      ctx.beginPath();
      ctx.strokeStyle = `hsla(${layer.hueShift}, 70%, ${lerp(18,30,1-layer.t)}%, 0.12)`;
      ctx.lineWidth = Math.max(0.5, 2*(1-layer.t));
      ctx.ellipse(0,0, rX, rY, 0, 0, Math.PI*2);
      ctx.stroke();
      ctx.restore();

      // bodies on this ellipse
      for (let p = 0; p < layer.points; p++){
        // phase for this body
        const localPhase = layer.phase + p * (Math.PI*2 / layer.points);
        // angular position moves with spin; use non-integer frequency for drift
        const ang = localPhase + time * layer.spin * (1 + 0.2*Math.sin(time*0.0009 + p));
        // map angle to elliptical coordinates & apply tilt
        const x0 = Math.cos(ang) * rX;
        const y0 = Math.sin(ang) * rY;
        // rotate by tilt
        const ct = Math.cos(layer.tilt), st = Math.sin(layer.tilt);
        const x = x0*ct - y0*st;
        const y = x0*st + y0*ct;
        // slight radial pulsation & size variance
        const baseSize = Math.max(1.2, 6*(1 - layer.t*0.9));
        const size = baseSize * (0.7 + 0.5*Math.abs(Math.sin(time*0.002 + p)));
        // color by layer
        const hue = (layer.hueShift + Math.sin(time*0.0007 + p*0.4)*12) % 360;
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        drawGlow(x, y, size*12, {h: hue, s: 78, l: 54}, 0.6 * Number(glowInput.value));
        // core
        ctx.beginPath();
        ctx.fillStyle = `hsl(${hue} 92% ${Math.min(70,40 + layer.t*40)}%)`;
        ctx.arc(x, y, Math.max(0.8, size*0.9), 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
        // faint small trail dot (accent)
        ctx.fillStyle = `hsla(${hue}, 80%, 60%, 0.06)`;
        ctx.beginPath(); ctx.arc(x + Math.cos(ang*1.3)*4, y + Math.sin(ang*1.1)*4, 10*(0.05+layer.t), 0, Math.PI*2); ctx.fill();
      }
    }
    ctx.restore();

    // vignette
    ctx.save();
    const g = ctx.createRadialGradient(cx, cy, Math.min(W,H)*0.1, cx, cy, Math.max(W,H)*0.75);
    g.addColorStop(0, 'rgba(0,0,0,0)');
    g.addColorStop(1, 'rgba(0,0,0,0.45)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);
    ctx.restore();
  }

  // animation loop
  let last = performance.now();
  function loop(now){
    const dt = now - last;
    last = now;
    if (!paused) time += dt;
    render(dt);
    requestAnimationFrame(loop);
  }

  // initialize & start
  initSystem();
  loop(performance.now());

  // expose a re-seed on click of canvas for quick variants
  canvas.addEventListener('click', (e) => {
    // small click changes seed slightly for immediate variety
    const s = Number(seedInput.value) || 1;
    seedInput.value = s + 1;
    rng = mulberry32(Number(seedInput.value));
    initSystem();
  });

  // nice: allow drag to change seed quickly
  let mouseDownX = null;
  canvas.addEventListener('mousedown', (e) => { mouseDownX = e.clientX; });
  window.addEventListener('mouseup', (e) => { 
    if (mouseDownX !== null) {
      const diff = Math.floor((e.clientX - mouseDownX) / 10);
      if (Math.abs(diff) > 0) {
        seedInput.value = (Number(seedInput.value) || 1) + diff;
        rng = mulberry32(Number(seedInput.value));
        initSystem();
      }
    }
    mouseDownX = null;
  });

})(); 
</script>
</body>
</html>
